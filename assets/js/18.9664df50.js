(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{383:function(_,v,e){_.exports=e.p+"assets/img/2NF.3d313c73.png"},465:function(_,v,e){"use strict";e.r(v);var t=e(28),a=Object(t.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h3",{attrs:{id:"_1-什么是数据库-数据库管理系统-数据库系统-数据库管理员"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是数据库-数据库管理系统-数据库系统-数据库管理员"}},[_._v("#")]),_._v(" 1.什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?")]),_._v(" "),t("ul",[t("li",[_._v("数据库(DataBase 简称 DB): "),t("code",[_._v("信息的集合")]),_._v("或者说数据库是由数据库管理系统管理的数据的集合")]),_._v(" "),t("li",[_._v("数据库管理系统(Database Management System 简称 DBMS): 一种"),t("code",[_._v("操纵和管理数据库的大型软件")]),_._v("，通常用于建立、使用和维护数据库")]),_._v(" "),t("li",[_._v("数据库系统(Data Base System，简称 DBS): 通常由"),t("code",[_._v("软件、数据库和数据管理员(DBA)组成")])]),_._v(" "),t("li",[_._v("数据库管理员(Database Administrator, 简称 DBA): 负责全面"),t("code",[_._v("管理和控制数据库系统")])])]),_._v(" "),t("h3",{attrs:{id:"_2-什么是元组-码-候选码-主码-外码-主属性-非主属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-什么是元组-码-候选码-主码-外码-主属性-非主属性"}},[_._v("#")]),_._v(" 2.什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？")]),_._v(" "),t("ul",[t("li",[_._v("元组(tuple): "),t("code",[_._v("关系数据库中的")]),_._v("基本概念，关系是一张表，表中的"),t("code",[_._v("每行")]),_._v("(即"),t("code",[_._v("数据库中的每条记录")]),_._v(")就是一个元组，每列就是一个属性。 在二维表里，元组也称为行")]),_._v(" "),t("li",[_._v("码: 能"),t("code",[_._v("唯一标识实体的属性")]),_._v("，对应表中的列")]),_._v(" "),t("li",[_._v("候选码: 若关系中的"),t("code",[_._v("某一属性或属性组")]),_._v("的值能"),t("code",[_._v("唯一的标识一个元组")]),_._v("，而其任何、子集都不能再标识，则称该属性组为候选码")])]),_._v(" "),t("blockquote",[t("p",[_._v("在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码")])]),_._v(" "),t("ul",[t("li",[_._v("主码: 也叫"),t("code",[_._v("主键")]),_._v("，是"),t("code",[_._v("从候选码中选出")]),_._v("来的")])]),_._v(" "),t("blockquote",[t("p",[_._v("一个实体集中只能有一个主码，但可以有多个候选码")])]),_._v(" "),t("ul",[t("li",[_._v("外码: 也叫"),t("code",[_._v("外键")]),_._v("，如果"),t("code",[_._v("一个关系中的一个属性是另外一个关系中的主码")]),_._v("则这个属性为外码")]),_._v(" "),t("li",[_._v("主属性: 候选码中出现过的属性称为主属性")])]),_._v(" "),t("blockquote",[t("p",[_._v("关系 工人(工号，身份证号，姓名，性别，部门). 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性")])]),_._v(" "),t("ul",[t("li",[_._v("非主属性: 不包含在任何一个候选码中的属性称为非主属性")])]),_._v(" "),t("blockquote",[t("p",[_._v("在关系——学生(学号，姓名，年龄，性别，班级)中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性")])]),_._v(" "),t("h3",{attrs:{id:"_3-数据库范式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-数据库范式"}},[_._v("#")]),_._v(" 3.数据库范式")]),_._v(" "),t("ul",[t("li",[_._v("1NF(第一范式)：属性不可再分，即这个字段只能是一个值，不能再分为多个其他的字段")])]),_._v(" "),t("blockquote",[t("p",[_._v("1NF 是所有关系型数据库的最基本要求 ，也就是说关系型数据库中创建的表一定满足第一范式")])]),_._v(" "),t("ul",[t("li",[t("p",[_._v("2NF(第二范式)：1NF 的基础之上，"),t("code",[_._v("消除了")]),_._v("非主属性对于码的"),t("code",[_._v("部分函数依赖")]),_._v(" "),t("img",{attrs:{src:e(383),alt:""}})])]),_._v(" "),t("li",[t("p",[_._v("3NF(第三范式)：3NF 在 2NF 的基础之上，"),t("code",[_._v("消除了")]),_._v("非主属性对于码的"),t("code",[_._v("传递函数依赖")])])])]),_._v(" "),t("blockquote",[t("p",[_._v("符合 3NF 要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号，姓名，系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求")])]),_._v(" "),t("h3",{attrs:{id:"_4-函数依赖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-函数依赖"}},[_._v("#")]),_._v(" 4.函数依赖")]),_._v(" "),t("ul",[t("li",[_._v("函数依赖(functional dependency): 若在一张表中，在属性(或属性组)X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y")]),_._v(" "),t("li",[_._v("部分函数依赖(partial functional dependency): 如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖")])]),_._v(" "),t("blockquote",[t("p",[_._v("学生基本信息表 R 中(学号，身份证号，姓名)当然学号属性取值是唯一的，在 R 关系中，(学号，身份证号)->(姓名)，(学号)->(姓名)，(身份证号)->(姓名)；所以姓名部分函数依赖于(学号，身份证号)")])]),_._v(" "),t("ul",[t("li",[_._v("完全函数依赖(Full functional dependency): 在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖")])]),_._v(" "),t("blockquote",[t("p",[_._v("学生基本信息表 R(学号，班级，姓名)假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，(学号，班级)->(姓名)，但是(学号)->(姓名)不成立，(班级)->(姓名)不成立，所以姓名完全函数依赖于(学号，班级)")])]),_._v(" "),t("ul",[t("li",[_._v("传递函数依赖: 在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，(X∪Y)∩Z=空集合，则称 Z 传递函数依赖(transitive functional dependency)于 X。传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中")])]),_._v(" "),t("blockquote",[t("p",[_._v("在关系 R(学号，姓名，系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖")])]),_._v(" "),t("h3",{attrs:{id:"_5-主键与外键"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-主键与外键"}},[_._v("#")]),_._v(" 5.主键与外键")]),_._v(" "),t("ul",[t("li",[_._v("主键：用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。")]),_._v(" "),t("li",[_._v("外键：用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。")])]),_._v(" "),t("h3",{attrs:{id:"_6-为什么不推荐使用外键与级联"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-为什么不推荐使用外键与级联"}},[_._v("#")]),_._v(" 6.为什么不推荐使用外键与级联")]),_._v(" "),t("ul",[t("li",[_._v("增加了复杂性：DELETE 或者 UPDATE 都必须考虑外键约束。外键的主从关系是定的，不利于需求变更。")]),_._v(" "),t("li",[_._v("对分库分表不友好：分库分表下外键是无法生效。")]),_._v(" "),t("li",[_._v("增加了额外工作：为了保证数据的的一致性和正确性，数据库需要增加维护外键的工作、消耗资源。")])]),_._v(" "),t("blockquote",[t("p",[_._v("以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新"),t("code",[_._v("适用于单机低并发，不适合分布式、高并发集群")]),_._v("; 级联更新是强阻塞，存在数据库更新风暴的风险; 外键影响数据库的插入速度")])]),_._v(" "),t("h3",{attrs:{id:"_7-什么是存储过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-什么是存储过程"}},[_._v("#")]),_._v(" 7.什么是存储过程")]),_._v(" "),t("ul",[t("li",[_._v("可以把存储过程看成是加了逻辑控制语句的 SQL 语句的集合")]),_._v(" "),t("li",[_._v("存储过程是预编译的，比单纯 SQL 语句执行要快，在业务比较复杂的时候非常实用")])]),_._v(" "),t("h3",{attrs:{id:"_8-drop、delete-与-truncate-区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-drop、delete-与-truncate-区别"}},[_._v("#")]),_._v(" 8.drop、delete 与 truncate 区别")]),_._v(" "),t("ul",[t("li",[_._v("用法不同\n"),t("ul",[t("li",[_._v("drop table 表名，直接将包含表结构的整个表都删掉")]),_._v(" "),t("li",[_._v("truncate table 表名，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始")]),_._v(" "),t("li",[_._v("delete from 表名 where 列名=值， 删除某一行的数据，如果不加 where 子句和truncate table 表名作用类似")])])]),_._v(" "),t("li",[_._v("属于不同的数据库语言\n"),t("ul",[t("li",[_._v("truncate 和 drop 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger")]),_._v(" "),t("li",[_._v("delete 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segement 中，事务提交之后才生效")])])]),_._v(" "),t("li",[_._v("执行速度不同\n"),t("ul",[t("li",[_._v("一般来说drop > truncate > delete")]),_._v(" "),t("li",[_._v("drop命令会把表占用的空间全部释放掉")]),_._v(" "),t("li",[_._v("truncate命令执行的时候"),t("code",[_._v("不会产生数据库日志")]),_._v("，还会把表的"),t("code",[_._v("自增值重置")]),_._v("和"),t("code",[_._v("索引恢复")]),_._v("到初始大小等")]),_._v(" "),t("li",[_._v("delete命令执行的时候会"),t("code",[_._v("产生数据库的binlog日志")]),_._v("，需要消耗时间的，好处是"),t("code",[_._v("方便数据回滚恢复")])])])])]),_._v(" "),t("h3",{attrs:{id:"_9-dml-语句和-ddl-语句"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-dml-语句和-ddl-语句"}},[_._v("#")]),_._v(" 9.DML 语句和 DDL 语句")]),_._v(" "),t("ul",[t("li",[_._v("DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中"),t("code",[_._v("表记录的操作")]),_._v("，主要包括表记录的插入、更新、删除和查询，是"),t("code",[_._v("开发人员")]),_._v("日常使用最频繁的操作")]),_._v(" "),t("li",[_._v("DDL（Data Definition Language）是数据定义语言的缩写，简单来说，就是对"),t("code",[_._v("数据库内部对象进行创建、删除、修改的操作")]),_._v("语言。DDL 语句更多的被"),t("code",[_._v("数据库管理员")]),_._v("（DBA）所使用，一般的开发人员很少使用")])]),_._v(" "),t("blockquote",[t("p",[_._v("DDL 和 DML 语言的最大区别是"),t("code",[_._v("DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象")]),_._v("。")])]),_._v(" "),t("h3",{attrs:{id:"_10-数据库设计通常分为哪几步"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-数据库设计通常分为哪几步"}},[_._v("#")]),_._v(" 10.数据库设计通常分为哪几步")]),_._v(" "),t("ul",[t("li",[_._v("需求分析 : 分析用户的需求，包括数据、功能和性能需求")]),_._v(" "),t("li",[_._v("概念结构设计 : 主要采用 E-R 模型进行设计，包括画 E-R 图")]),_._v(" "),t("li",[_._v("逻辑结构设计 : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换")]),_._v(" "),t("li",[_._v("物理结构设计 : 主要是为所设计的数据库选择合适的存储结构和存取路径")]),_._v(" "),t("li",[_._v("数据库实施 : 包括编程、测试和试运行")]),_._v(" "),t("li",[_._v("数据库的运行和维护 : 系统的运行与数据库的日常维护")])])])}),[],!1,null,null,null);v.default=a.exports}}]);