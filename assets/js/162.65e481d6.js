(window.webpackJsonp=window.webpackJsonp||[]).push([[162],{582:function(t,n,a){"use strict";a.r(n);var e=a(28),s=Object(e.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"what"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what"}},[t._v("#")]),t._v(" what")]),t._v(" "),a("ul",[a("li",[t._v("首先，JS 是一门语言，意味着其\n"),a("ul",[a("li",[t._v("有独立的"),a("a",{attrs:{href:""}},[t._v("语法规范")])]),t._v(" "),a("li",[t._v("提供一些内置对象和 API（如数组、对象、函数等）")])])]),t._v(" "),a("li",[t._v("其次，JS 是 Dynamically Typed Language 即动态类型语言，意味着其\n"),a("ul",[a("li",[t._v("运行时才去做类型检查\n"),a("ul",[a("li",[t._v("需要借助eslint等三方工具实现运行时的类型检查")])])]),t._v(" "),a("li",[t._v("是一门弱类型语言")]),t._v(" "),a("li",[t._v("有多种运行时\n"),a("ul",[a("li",[t._v("nodejs")]),t._v(" "),a("li",[t._v("deno")])])])])]),t._v(" "),a("li",[t._v("🖋️ing...")])]),t._v(" "),a("h1",{attrs:{id:"特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特性"}},[t._v("#")]),t._v(" 特性")]),t._v(" "),a("h5",{attrs:{id:"_1-变量提升"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-变量提升"}},[t._v("#")]),t._v(" 1. 变量提升")]),t._v(" "),a("blockquote",[a("p",[t._v("var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined，let、const命令会报错")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\t// var 的情况\n\tconsole.log(foo); // 输出undefined\n\tvar foo = 2;\n\n\t// let 的情况\n\tconsole.log(bar); // 报错ReferenceError\n\tlet bar = 2;\n")])])]),a("h5",{attrs:{id:"_2-暂时性死区-temporal-dead-zone-简称-tdz"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-暂时性死区-temporal-dead-zone-简称-tdz"}},[t._v("#")]),t._v(" 2. 暂时性死区(temporal dead zone，简称 TDZ)")]),t._v(" "),a("blockquote",[a("p",[t._v("只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\tvar tmp = 123;\n\n\tif (true) {\n  \ttmp = 'abc'; // ReferenceError\n \t  let tmp;\n\t}\n")])])]),a("h5",{attrs:{id:"_3-暂时性死区与typeof"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-暂时性死区与typeof"}},[t._v("#")]),t._v(" 3. 暂时性死区与typeof")]),t._v(" "),a("blockquote",[a("p",[t._v("“暂时性死区”意味着typeof不再是一个百分之百安全的操作。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('\ttypeof x; // ReferenceError\n\tlet x;\n\n\ttypeof undeclared_variable // "undefined"\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\tfunction bar(x = y, y = 2) {\n \t  return [x, y];\n\t}\n\tbar(); // 报错\n\n\tfunction bar(x = 2, y = x) {\n  \t  return [x, y];\n\t}\n\tbar(); // [2, 2]\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\t// 不报错\n\tvar x = x;\n\n\t// 报错\n\tlet x = x;\n\t// ReferenceError: x is not defined\n\n\t// 报错\n\tconst x = x;\n\t// Cannot access 'x' before initialization\n")])])]),a("blockquote",[a("p",[t._v("暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。")])]),t._v(" "),a("h5",{attrs:{id:"_4-块级作用域与匿名立即执行函数表达式-匿名-iife"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-块级作用域与匿名立即执行函数表达式-匿名-iife"}},[t._v("#")]),t._v(" 4. 块级作用域与匿名立即执行函数表达式（匿名 IIFE）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\t// IIFE 写法\n\t(function () {\n \t  var tmp = ...;\n \t ...\n\t}());\n\n\t// 块级作用域写法\n\t{\n \t  let tmp = ...;\n  \t...\n\t}\n")])])]),a("h5",{attrs:{id:"_5-块级作用域与函数声明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-块级作用域与函数声明"}},[t._v("#")]),t._v(" 5. 块级作用域与函数声明")]),t._v(" "),a("blockquote",[a("p",[t._v("ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\t// 情况一，应该报错但未报错\n\tif (true) {\n \t  function f() {}\n\t}\n\n\t// 情况二，应该报错但未报错\n\ttry {\n \t  function f() {}\n\t} catch(e) {\n \t  // ...\n\t}\n")])])]),a("blockquote",[a("p",[t._v("但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。")])]),t._v(" "),a("h5",{attrs:{id:"_6-块级作用域与函数提升"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-块级作用域与函数提升"}},[t._v("#")]),t._v(" 6. 块级作用域与函数提升")]),t._v(" "),a("blockquote",[a("p",[t._v("ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。")])]),t._v(" "),a("blockquote",[a("p",[t._v("ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\tfunction f() { console.log('I am outside!'); }\n\t(function () {\n  \t  if (false) {\n    \t// 重复声明一次函数f\n    \tfunction f() { console.log('I am inside!'); }\n  \t  }\n  \t  f();\n\t}());\n\n\t// ES5 环境\n\tfunction f() { console.log('I am outside!'); }\n\t (function () {\n  \t   function f() { console.log('I am inside!'); }\n  \t   if (false) {\n  \t   }\n \t   f();\n\t}());\n\t// I am inside!\n\n\t// 浏览器的 ES6 环境\n\tfunction f() { console.log('I am outside!'); }\n\t (function () {\n  \t   var f = undefined;\n  \t   if (false) {\n    \t function f() { console.log('I am inside!'); }\n  \t   }\n  \t   f();\n\t}());\n\t// Uncaught TypeError: f is not a function\n")])])]),a("blockquote",[a("p",[t._v("ES5中存在函数提升，为了兼容ES5，ES6中规定函数声明提升规则")]),t._v(" "),a("ul",[a("li",[t._v("允许在块级作用域内声明函数。")]),t._v(" "),a("li",[t._v("函数声明类似于var，即会提升到全局作用域或函数作用域的头部。")]),t._v(" "),a("li",[t._v("同时，函数声明还会提升到所在的块级作用域的头部。")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);